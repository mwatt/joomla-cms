<attach event="ondocumentready" handler="_ParseStylesheets" />
<script language="JScript">
/**
 *	ADxMenu behavior - enterprise - v0.21
 *	- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 *	(c) 2004 - Aleksandar Vacic, www.aplus.co.yu
 * Licensed under http://creativecommons.org/licenses/by/2.0/
 *	- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Based on PSEUDOS V1.20.040828
 *	http://www.xs4all.nl/~peterned/csshover.html
 *	(c) 2004 - Peter Nederlof
 *	- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 */

var _oCurrentSheet, _oDoc = window.document;
var _aActivators = {
	onhover:{on:'onmouseover', off:'onmouseout'}
}

//	keeps the menu IDs
var _aMenuIDs = new Array();

//	find menus on the page - look for class named "adxm"
function _FindMenus() {
	var aTmp = xGetElementsByClassName("adxm", element.document, "ul", function(oM) {
		_Add(oM.id);
	} );
};

//	add the menu to the array
function _Add(sMenuID) {
	if ( typeof(sMenuID) == "undefined" ) return;
	_aMenuIDs[_aMenuIDs.length] = sMenuID.replace(/List/, "");
};

function _ParseStylesheets() {
	_FindMenus();
	_Setup();	//WCH
	var sheets = _oDoc.styleSheets, l = sheets.length;
	for(var i=0; i<l; i++) 
		_ParseStylesheet(sheets[i]);
}

function _ParseStylesheet(sheet) {
	var l, rules, imports;
	if(sheet.imports) {
		imports = sheet.imports, l = imports.length;
		for(var i=0; i<l; i++) 
			_ParseStylesheet(sheet.imports[i]);
	}
	rules = (_oCurrentSheet = sheet).rules, l = rules.length;
	for(var j=0; j<l; j++) _ParseCSSRule(rules[j]);
}

function _ParseCSSRule(rule) {
	var select = rule.selectorText, style = rule.style.cssText;

	//	if style text is empty, IE throws "invalid pointer" error	
	if ( style.replace(/ /, "") == "" ) return;
	
	//	work only with #menu
	var sMenuID, bFound = 0;
	for (var t=0;t<_aMenuIDs.length;t++) {
		if (select.indexOf(_aMenuIDs[t]) != -1) {
			bFound = 1;
			sMenuID = _aMenuIDs[t];
			break;
		}
	}
	if (!bFound) return;

	if(!(/(^|\s)(([^a]([^ ]+)?)|(a([^#.][^ ]+)+)):(hover)/i).test(select)) return;
	
	var pseudo = select.replace(/[^:]+:([a-z-]+).*/i, 'on$1');
	var newSelect = select.replace(/(\.([a-z0-9_-]+):[a-z]+)|(:[a-z]+)/gi, '.$2' + pseudo);
	var className = (/\.([a-z0-9_-]+)/i).exec(newSelect)[1];
	var affected = select.replace(/:hover.*$/, '');

	//	remove the #menu part
	eval('affected = affected.replace(/#' + sMenuID + '([ ]+)/i, "")');

	var elements = _GetElementsBySelect(affected, sMenuID);

	_oCurrentSheet.addRule(newSelect, style);
	for(var i=0; i<elements.length; i++)
		new _HoverElement(elements[i], className, _aActivators[pseudo], sMenuID);
}

function _HoverElement(node, className, events, sMenuID) {
	if(!node.hovers) node.hovers = {};
	if(node.hovers[className]) return;
	node.hovers[className] = true;

	if (node.className.indexOf("submenu") != -1) {
		node.wch = true;
		node.submenu = node.getElementsByTagName("ul")[0];
	}
	node.parentMenu = node.parentNode;
	node.bIsH = false;
	if (node.parentMenu.id == (sMenuID + "List") && node.parentMenu.className.indexOf("adxmV") == -1) node.bIsH = true;

	node.attachEvent(events.on,
		function() {
						node.className += ' ' + className;
						if (node.submenu) {
							_Repos(node);
						}
						if (node.wch) {
							_Apply(node.submenu, node, true);
							node.parentMenu.shownMenu = node.submenu;
						}
					});
	node.attachEvent(events.off,
		function() {
						node.className = node.className.replace(new RegExp('\\s+'+className, 'g'),'');
						_HideWCH(node.parentMenu);
					});
}

var _bIsH = true;
function _GetElementsBySelect(rule, sMenuID) {
	//	work only inside of the #menu div
	var parts, nodes = [_oDoc.getElementById(sMenuID)];
/*	if ( nodes[0].className.indexOf("adxmV") != -1 )
		_bIsH = false;*/
	parts = rule.split(' ');
	for(var i=0; i<parts.length; i++) {
		nodes = _GetSelectedNodes(parts[i], nodes);
	}
	return nodes;
}

function _GetSelectedNodes(select, elements) {
	var result, node, nodes = [];
	var classname = (/\.([a-z0-9_-]+)/i).exec(select);
	var identify = (/\#([a-z0-9_-]+)/i).exec(select);
	var tagName = (/^[a-z0-9]+/i).exec(select.toUpperCase()) || '*';
	for(var i=0; i<elements.length; i++) {
		result = elements[i].getElementsByTagName(tagName);
		for(var j=0; j<result.length; j++) {
			node = result[j];
			if((identify && node.id != identify[1]) || (classname && !(new RegExp('\\b' +
				classname[1] + '\\b').exec(node.className)))) continue;
			nodes[nodes.length] = node;
		}
	}	return nodes;
}

//	WCH private properties
var _bIE55 = false;
var _bIE6 = false;
var _oRule = null;
var _bSetup = true;
var _oSelf = this;

function _Setup() {
	_bIE55 = (typeof(document.body.contentEditable) != "undefined");
	_bIE6 = (typeof(document.compatMode) != "undefined");

	if (!_bIE55) {
		var oSheet = element.document.styleSheets[0];
		oSheet.addRule(".WCHhider", "visibility:visible");
		_oRule = oSheet.rules(oSheet.rules.length-1);
	}

	_bSetup = false;
};

//	public: hides windowed controls
function _Apply(oLayer, oContainer, bResize) {
	if (_bSetup) _Setup();

	if ( _bIE55 && (oIframe = _Hider(oLayer, oContainer, bResize)) ) {
		oIframe.style.visibility = "visible";
	} else if(_oRule != null) {
		_oRule.style.visibility = "hidden";
	}

};

//	public: shows windowed controls
function _Discard(oLayer, oContainer) {
	if ( _bIE55 && (oIframe = _Hider(oLayer, oContainer, false)) ) {
		oIframe.style.visibility = "hidden";
	} else if(_oRule != null) {
		_oRule.style.visibility = "visible";
	}
};

//	private: returns iFrame reference for IE5.5+
function _Hider(oLayer, oContainer, bResize) {
	//	is it there already?
	var sHiderID = "WCHhider" + oLayer.id;
	var oIframe = element.document.getElementById(sHiderID);
	
	//	if not, create it
	if ( !oIframe ) {
		//	IE 6 has this property, IE 5 not. IE 5.5(even SP2) crashes when filter is applied, hence the check
		var sFilter = (_bIE6) ? "filter:progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=0);" : "";
		//	get z-index of the object. must be at least 2!
		zIndex = parseInt(oLayer.currentStyle.zIndex);
		if (isNaN(zIndex)) return null;
		//	add hider to the page
		oContainer.insertAdjacentHTML("afterBegin", '<iframe class="WCHiframe" src="javascript:document.write(\'' + sHiderID + '\');" id="' + sHiderID + '" scroll="no" frameborder="0" style="position:absolute;visibility:hidden;' + sFilter + 'border:0;top:0;left;0;width:0;height:0;background-color:transparent;z-index:' + (zIndex--) + ';"></iframe>');
		oIframe = element.document.getElementById(sHiderID);
		//	then do calculation
		_SetPos(oIframe, oLayer);
	} else if (bResize) {
		//	resize the iFrame if asked
		_SetPos(oIframe, oLayer);
	}
	return oIframe;
};

//	private: set size and position of the Hider
function _SetPos(oIframe, oLayer) {
	//	fetch and set size
	oIframe.style.width = oLayer.offsetWidth + "px";
	oIframe.style.height = oLayer.offsetHeight + "px";
	//	move to specified position
	oIframe.style.left = oLayer.offsetLeft + "px";
	oIframe.style.top = oLayer.offsetTop + "px";
};

function _HideWCH(oMenu) {
	var curmenu = oMenu.shownMenu;
	var prevMenu;
	while ( curmenu ) {
		//	show windowed controls for current child menu
		_Discard(curmenu);
		//	save the pointer to current child menu
		prevMenu = curmenu;
		//	prepare the next child menu
		curmenu = curmenu.shownMenu;
		//	kill the shownMenu info for current child menu
		prevMenu.shownMenu = null;
	}
};

//	reposition menu to fit in the viewport
function _Repos(oItem) {
	var nTmp;
	//	get the submenu pointer
	var oMenu = oItem.submenu;
	var bIsH = oItem.bIsH;

	//	full submenu size
	var nW = oMenu.offsetWidth;
	var nH = oMenu.offsetHeight;

	//	full parent item size, width + padding + border
	var nIW = oItem.offsetWidth;
	var nIH = oItem.offsetHeight;

	//	inner submenu size, width only
	if (nTmp = xGetComputedStyle(oItem, "width")) nIW = nTmp;
	if (nTmp = xGetComputedStyle(oItem, "height")) nIH = nTmp;

	//	where should menu be (top-left point) in parent item coordinates?
	var nLeft = (bIsH) ? 0 : nIW;
	var nTop = (bIsH) ? nIH : 0;

	//	where is that top-left menu point in page coordinates?
	var nPageX = xPageX(oItem) + nLeft;
	var nPageY = xPageY(oItem) + nTop;

	//	get available client dims (with scrolling included)
	_Viewport();
	var nClientW = _nCW;
	var nClientH = _nCH;

	if ( nClientW != 0 && nClientH != 0 ) {
		//	Horizontal placement
		var nDiff = 0;
		if (nPageX < 0) {
			nDiff += -nPageX;
			if (!bIsH) nDiff += nIW;
		} else {
			nTmp = nClientW - (nPageX + nW);
			if (nTmp < 0) {
				if (bIsH) {
					//	include the size of the parent item
					nDiff = nTmp-nIW;
					//	include the margins of the parent item
					if (nTmp = xGetComputedStyle(oItem, "marginLeft")) nDiff -= nTmp;
					if (nTmp = xGetComputedStyle(oItem, "marginRight")) nDiff -= nTmp;
				} else {
					nDiff = -nW-nIW;
				}
			}
		}
		if ( nDiff < 0 ) {
			oMenu.style.right = "auto";
			nLeft += nDiff;
			xLeft(oMenu, nLeft);
		}

		//	Vertical placement
		var nDiff = 0;
		if (nPageY < 0) {
			nDiff += -nPageY;
			if (bIsH) nDiff += nIH;
		} else {
			nTmp = nClientH - (nPageY + nH);
			if (nTmp < 0) {
				if (bIsH) {
					nDiff = -nH-nIH;
				} else {
					//	include the size of the parent item
					nDiff = nTmp-nIH;
					//	include the margins of the parent item
					if (nTmp = xGetComputedStyle(oItem, "marginTop")) nDiff -= nTmp;
					if (nTmp = xGetComputedStyle(oItem, "marginBottom")) nDiff -= nTmp;
				}
			}
		}
		if ( nDiff < 0 ) {
			oMenu.style.bottom = "auto";
			nTop += nDiff;
			xTop(oMenu, nTop);
		}
	}
};

//	fetch client width, including scrolled part
var _nCW = 0;
function _FetchCW() {
	var nTmp = xClientWidth();
	if (nTmp > 0) nTmp += xScrollLeft();
	_nCW = nTmp;
};

//	fetch client height, including scrolled part
var _nCH = 0;
function _FetchCH() {
	var nTmp = xClientHeight();
	if (nTmp > 0) nTmp += xScrollTop();
	_nCH = nTmp;
};

//	call this one for window.onresize
function _Viewport() {
	_FetchCH();
	_FetchCW();
};

/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	these functions are taken from Mike Foster's X library, and simplified where possible.
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
function xClientWidth() {
	var w = 0;
	if (_oDoc.documentElement && _oDoc.documentElement.clientWidth)
		w = _oDoc.documentElement.clientWidth;
	else if (_oDoc.body && _oDoc.body.clientWidth)
		w = _oDoc.body.clientWidth;
	return w;
}

function xClientHeight() {
	var h = 0;
	if (_oDoc.documentElement && _oDoc.documentElement.clientHeight)
		h = _oDoc.documentElement.clientHeight;
	else if (_oDoc.body && _oDoc.body.clientHeight)
		h = _oDoc.body.clientHeight;
	return h;
}

function xScrollLeft() {
	var offset = 0;
	if ( _oDoc.documentElement && _oDoc.documentElement.scrollLeft )
		offset = _oDoc.documentElement.scrollLeft;
	else if ( _oDoc.body && xDef(_oDoc.body.scrollLeft ) )
		offset = _oDoc.body.scrollLeft;
	return offset;
}

function xScrollTop() {
	var offset = 0;
	if ( _oDoc.documentElement && _oDoc.documentElement.scrollTop )
		offset = _oDoc.documentElement.scrollTop;
	else if ( _oDoc.body && xDef(_oDoc.body.scrollTop ) )
		offset = _oDoc.body.scrollTop;
	return offset;
}

function xLeft(e, iX) {
	if ( xDef(iX) )
		e.style.left = iX + "px";
	else {
		iX = e.offsetLeft;
	}
	return iX;
}

function xTop(e, iY) {
	if ( xDef(iY) )
		e.style.top = iY + "px";
	else {
		iY = e.offsetTop;
	}
	return iY;
}

function xPageX(e) {
	var x = 0;
	while (e) {
		x += e.offsetLeft;
		e = e.offsetParent;
	}
	return x;
}

function xPageY(e) {
	var y = 0;
	while (e) {
		y += e.offsetTop;
		e = e.offsetParent;
	}
	return y;
}

function xDef() {
	for (var i=0; i<arguments.length; ++i) {
		if ( typeof(arguments[i]) == "undefined" )
			return false;
	}
	return true;
}

function xGetComputedStyle(oEle, sProp) {
	var p = null;
	p = oEle.currentStyle[sProp];
	p = parseInt(p);
	return p;
}

function xGetElementsByClassName(clsName, parentEle, tagName, fn) {
	var found = new Array();
	var re = new RegExp('\\b'+clsName+'\\b', 'i');
	var list = parentEle.getElementsByTagName(tagName);
	for (var i = 0; i < list.length; ++i) {
		if (list[i].className.search(re) != -1) {
			found[found.length] = list[i];
			if (fn) fn(list[i]);
		}
	}
	return found;
}

</script>